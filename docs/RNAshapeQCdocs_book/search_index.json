[["index.html", "RNAshapeQC: User Manual 1 Introduction", " RNAshapeQC: User Manual Miyeon Yeon and Won-Young Choi 2025-12-16 1 Introduction This user manual provides a practical guide to using the RNAshapeQC package for RNA coverage-shape-based quality control metrics. It is designed for researchers who want to quantify RNA integrity, detect degraded or suboptimal samples, and visualize gene body coverage patterns across diverse RNA-seq datasets. The manual covers: preparing input files and directory structures running the core QC functions interpreting nonuniformity and coverage-shape metrics generating reproducible figures and summary tables Examples throughout the manual are based on subsets of real datasets (TCGA Pilot, TCGA-LUAD, and Alliance/CALGB) to illustrate workflows and outputs. "],["data-description.html", "2 Data Description Alliance/CALGB", " 2 Data Description We need datasets such as genelist, coverage pileup, and sampleInfo to obtain the sample quality index outputs and plots. Descriptions of the input data and variable names are provided below. genelist: a vector of gene names pileupPath: a vector for file paths of coverage pileupData including .RData file names geneInfo: a data frame of gene information including gene ID and properties gene_id: ensembl gene ID geneSymbol: gene names merged: gene length exon.wtpct_gc: weighted percentage of GC from exon level data subcategory: protein coding or lncRNA sampleInfo: a data frame of sample information including sample ID and properties from Picard RnaSeqMetrics SampleID: sample ID PF_BASES: the total number of bases within the PF_READS of the SAM or BAM file to be examined PF_ALIGNED_BASES: the total number of aligned bases, in all mapped PF reads, that are aligned to the reference sequence RIBOSOMAL_BASES: number of bases in primary alignments that align to ribosomal sequence CODING_BASES: number of bases in primary alignments that align to a non-UTR coding base for some gene, and not ribosomal sequence UTR_BASES: number of bases in primary alignments that align to a UTR base for some gene, and not a coding base INTRONIC_BASES: number of bases in primary alignments that align to an intronic base for some gene, and not a coding or UTR base INTERGENIC_BASES: number of bases in primary alignments that do not align to any gene RINs: RIN value TPM: a data frame for TPM normalization Alliance/CALGB This example consists of 1,000 selected genes among protein coding and lncRNA genes and fresh frozen and total RNA-seq (FFT) 171 samples. Among the samples, 156 are tumor types and the others are normal. The summary table from summarytools show descriptive statistics to review the distribution and missing values for the provided datasets. library(summarytools) library(dplyr) descr( sampleInfo %&gt;% select(-c(SampleID)), stats = c(&quot;min&quot;, &quot;med&quot;, &quot;max&quot;, &quot;n.valid&quot;), transpose = TRUE, headings = FALSE ) ## ## Min Median Max N.Valid ## ---------------------- --------------- ---------------- ---------------- --------- ## CODING_BASES 360227386.00 3208673516.00 7201831541.00 171.00 ## INTERGENIC_BASES 1273275706.00 2567603596.00 16945505453.00 171.00 ## INTRONIC_BASES 434293079.00 5593128001.00 10076495286.00 171.00 ## PF_ALIGNED_BASES 5448216119.00 14566862147.00 23291961710.00 171.00 ## PF_BASES 6481274100.00 16315945500.00 26148083100.00 171.00 ## RIBOSOMAL_BASES 0.00 150.00 6600.00 171.00 ## RINs 1.10 5.30 9.20 167.00 ## UTR_BASES 381863999.00 2783953295.00 4803719959.00 171.00 "],["data-generation.html", "3 Data Generation 3.1 BAM slicing 3.2 Pileup", " 3 Data Generation 3.1 BAM slicing The relevant reads can be extracted for efficient analysis on a subset of genes. STAR and samtools enable output sorted alignments to Aligned.out.sort.bam file. For simple explanation of data generating steps, suppose that we only consider a case of gene KEAP1 and 5 samples in the bamfiles folder. A comprehensive gene annotation file (GTF) gencode.v36.annotation.gtf can be downloaded at GENCODE. gtftools is able to save gene coordination and ID mappings in bed format as gencode.v36.genes.bed from the GTF file, and then genomic region for KEAP1 be obtained as genic_region.bed. bedfile=&quot;$base/gencode.v36.genes.bed&quot; genome_region=$( grep -P $genename&quot;\\t&quot; $bedfile \\ | cut -f5 ) awk -v gene=&quot;$genename&quot; -F&#39;\\t&#39; &#39; $7 == gene {print $1, $2, $3} &#39; OFS=&#39;\\t&#39; &quot;$bedfile&quot; &gt; $geneDir/bamslice/genic_region.bed The samtools and BEDTools are required, and inputs to get a sliced BAM for the specific gene and sample are given: Gene of interest Genomic coordinates to extract reads Input directory for BAM files Output directory for sliced BAM files Prefix for output BAM files genename=&quot;KEAP1&quot; genome_region=&quot;chr19:10486124-10503558&quot; ibampath=&quot;/bamfiles/A001_Aligned.out.sort.bam&quot; bamsliceDir=&quot;/bamslice&quot; ibamslice=&quot;KEAP1_A001_slice&quot; We define 3 cases to select reads within genome region of a gene: *_contained.bam: both paired reads are in the genome region (black line) *_overlap_Sonly.bam: one of paired reads overlaps with the start genomic position (red line) *_overlap_Eonly.bam: one of paired reads overlaps with the end genomic position (green line) The samtools can extract paired-end reads in *_1.bam and *_2.bam from BAM files and merge as *_temp.bam. Based on overlap with the gene, intersectBed from BEDTools identifies reads and start and end positions of the gene are created in *_genes_S.bed and *_genes_E.bed. # Slice BAM by read orientation (flags 147 and 99) samtools view -b -f 147 ${ibampath} $genome_region \\ &gt; $bamsliceDir/${ibamslice}_1.bam samtools view -b -f 99 ${ibampath} $genome_region \\ &gt; $bamsliceDir/${ibamslice}_2.bam samtools merge -f \\ $bamsliceDir/${ibamslice}_temp.bam \\ $bamsliceDir/${ibamslice}_1.bam \\ $bamsliceDir/${ibamslice}_2.bam # Intersect with genic region intersectBed \\ -a $bamsliceDir/${ibamslice}_temp.bam \\ -b $bamsliceDir/genic_region.bed \\ &gt; $bamsliceDir/${ibamslice}_overlap.bam intersectBed \\ -a $bamsliceDir/${ibamslice}_temp.bam \\ -b $bamsliceDir/genic_region.bed \\ -f 1.0 \\ &gt; $bamsliceDir/${ibamslice}_contained.bam # Start (S) / End (E) positions as 1bp BED awk &#39;{print $1&quot;\\t&quot;$2&quot;\\t&quot;$2}&#39; $bamsliceDir/genic_region.bed \\ &gt; $bamsliceDir/${ibamslice}_genes_S.bed awk &#39;{print $1&quot;\\t&quot;$3&quot;\\t&quot;$3}&#39; $bamsliceDir/genic_region.bed \\ &gt; $bamsliceDir/${ibamslice}_genes_E.bed After identifying reads overlapping only the start or end of gene, we can merge with reads fully contained within the gene to make a preliminary BAM file as *_pre.bam. The final files are a sorted BAM file *.bam and a BAM index file *.bam.bai, and removing all intermediate files are recommended to optimize storage. # Reads overlapping start but not end -&gt; S-only intersectBed \\ -a $bamsliceDir/${ibamslice}_overlap.bam \\ -b $bamsliceDir/${ibamslice}_genes_S.bed \\ | intersectBed \\ -a stdin \\ -b $bamsliceDir/${ibamslice}_genes_E.bed \\ -v \\ &gt; $bamsliceDir/${ibamslice}_overlap_Sonly.bam # Reads overlapping end but not start -&gt; E-only intersectBed \\ -a $bamsliceDir/${ibamslice}_overlap.bam \\ -b $bamsliceDir/${ibamslice}_genes_E.bed \\ | intersectBed \\ -a stdin \\ -b $bamsliceDir/${ibamslice}_genes_S.bed \\ -v \\ &gt; $bamsliceDir/${ibamslice}_overlap_Eonly.bam # Merge all parts samtools merge -o $bamsliceDir/${ibamslice}_pre.bam \\ $bamsliceDir/${ibamslice}_contained.bam \\ $bamsliceDir/${ibamslice}_overlap_Sonly.bam \\ $bamsliceDir/${ibamslice}_overlap_Eonly.bam # Sort &amp; Index samtools sort $bamsliceDir/${ibamslice}_pre.bam \\ &gt; $bamsliceDir/${ibamslice}.bam samtools index \\ $bamsliceDir/${ibamslice}.bam \\ $bamsliceDir/${ibamslice}.bam.bai # Cleanup temporary files rm \\ $bamsliceDir/${ibamslice}_1.bam \\ $bamsliceDir/${ibamslice}_2.bam \\ $bamsliceDir/${ibamslice}_temp.bam \\ $bamsliceDir/${ibamslice}_overlap.bam \\ $bamsliceDir/${ibamslice}_contained.bam \\ $bamsliceDir/${ibamslice}_pre.bam \\ $bamsliceDir/${ibamslice}_genes_S.bed \\ $bamsliceDir/${ibamslice}_genes_E.bed \\ $bamsliceDir/${ibamslice}_overlap_Sonly.bam \\ $bamsliceDir/${ibamslice}_overlap_Eonly.bam 3.2 Pileup SCISSOR package1 can be applied to generate pileup from BAM file, region info, and coverage plots based on its tutorial. From the GTF file, build_gaf() function creates a region info file named SCISSOR_gaf.txt and shows the full path of the file. The file contains regions by gene_name and gene_id. library(SCISSOR) build_gaf(GTF.file=&quot;./dataPrep/gencode.v36.annotation.gtf&quot;) For instance, we can make pileup and compare coverage plots of part_intron and only_exon using gene KEAP1 and the 5 samples. If 5 sliced BAM files are saved in the bamslice folder, the full file path of them can be set as BAMfiles. gen_pileup() function saves pileup, regions, and Ranges for Gene, which become inputs to plot pileup figures. BAMfiles &lt;- list.files(path=paste0(&quot;../bamslice&quot;), pattern=&quot;\\\\.sort.bam$&quot;, full.names=TRUE) caseIDs &lt;- substr(basename(BAMfiles), start=6, stop=22) gen_pileup = function(Gene, regionsFile, BAMfiles, caseIDs, outputdir) { if (!Gene %in% regionsFile$gene_name) { stop(Gene, &quot; is not in gene_name of SCISSOR_gaf.txt&quot;) } regions &lt;- as.character(regionsFile[match(Gene, regionsFile$gene_name), c(&quot;regions&quot;)]) Ranges = SCISSOR::get_Ranges(Gene=Gene, regions=regions, outputType=&quot;part_intron&quot;) pileup = SCISSOR::read_BAM(BAMfiles=BAMfiles, caseIDs=caseIDs, regions=regions) save(pileup, regions, Ranges, file=paste0(outputdir, Gene, &quot;_pileup_part_intron.RData&quot;)) } gen_pileup( Gene = &quot;KEAP1&quot;, regionsFile = data.table::fread(file=&quot;./dataPrep/SCISSOR_gaf.txt&quot;), BAMfiles = BAMfiles, caseIDs = caseIDs, outputdir = paste0(&quot;../pileup/&quot;) ) par(mfrow=c(1,2)) # part_intron load(paste0(&quot;../pileup/KEAP1_pileup_part_intron.RData&quot;)) plot_pileup( Pileup = log10(pileup+1), case = caseIDs, Ranges = Ranges, logcount = 1, main = &quot;part_intron&quot; ) # only_exon pileupData = build_pileup( Pileup = pileup, case = caseIDs, regions = regions, inputType = &quot;part_intron&quot;, outputType = &quot;only_exon&quot; ) geneRanges = get_Ranges( Gene = Ranges$Gene, regions = regions, outputType = &quot;only_exon&quot; ) plot_pileup( Pileup = log10(pileupData+1), case = caseIDs, Ranges = geneRanges, logcount = 1, main = &quot;only_exon&quot; ) The only_exon figure has 10 exons after filtering introns from part_intron. The start and end positions for exon (e) and intronic part (ip) per exon are matched with the pileup plot and we only consider exon to measure sample quality. Ranges$gRanges ## ip.start e.start e.end ip.end ## exon1 10503558 10503558 10503241 10503187 ## exon2 10503186 10503186 10503093 10502897 ## exon3 10502896 10502896 10502697 10502688 ## exon4 10502687 10502687 10502388 10502039 ## exon5 10500429 10500080 10499395 10499046 ## exon6 10493066 10492717 10492573 10492263 ## exon7 10492262 10492262 10491577 10491228 ## exon8 10490202 10489853 10489648 10489436 ## exon9 10489435 10489435 10489192 10488843 ## exon10 10487167 10486818 10486125 10486125 Choi, H.Y., Jo, H., Zhao, X. et al. SCISSOR: a framework for identifying structural changes in RNA transcripts. Nat Commun 12, 286 (2021). https://doi.org/10.1038/s41467-020-20593-3↩︎ "],["GeneBodyCoverage.html", "4 Data Processing", " 4 Data Processing The union transcript is used to extract only exon pileup. To keep only exon location, we first build coverage pileup from raw pileup (part_intron) to pileupData (only_exon). Gene length normalization is required because gene length is a major confounder in coverage shape, raw signal intensity, and degradation sensitivity. Without length normalization, comparisons across genes or across samples become misleading. In our package, gene length normalization has two options to select read depth at the region: raw value and interpolation. After evenly dividing genomic positions by the number of regions (red vertical broken lines), suppose that both sides and center of regions are x-values of odd and even points, respectively. While the first method finds read depth at even points (green points), and the second one finds geometric mean (blue points) using read depth at odd points (red points). We recommend using the gene length normalization methods for gene length is at least 2\\(\\times\\)the number of regions+1 to secure minimum read depth selection across genes. Before the coverage normalization, identification and filter low-expression genes need by the filter_lowExpGenes() function to reduce sampling noise. Only 961 out of 1,000 genes are used for gene body coverage when considering genes for which fewer than 50% of samples have TPM &lt; 5. Genes are separated into two groups to compare base coverage patterns in short and long genes. 0~5 kb and 5+ kb cover 96 and 865 genes, respectively. pileupPath &lt;- paste0(&quot;../pileup/&quot;, genelist, &quot;_pileup_part_intron.RData&quot;) # Filtered genes genelist2 &lt;- filter_lowExpGenes(genelist, TPM, thr=5, pct=50) pileupPath2 &lt;- paste0(&quot;../pileup/&quot;, genelist2, &quot;_pileup_part_intron.RData&quot;) geneInfo2 &lt;- geneInfo[match(genelist2, geneInfo$geneSymbol), ] %&gt;% mutate( merged_kb = merged/1000, Len = factor(case_when( merged_kb&gt;=0 &amp; merged_kb&lt;5 ~ &quot;0~5 kb&quot;, merged_kb&gt;=5 ~ &quot;5+ kb&quot;, is.na(merged_kb) ~ NA) ), LenSorted = forcats::fct_relevel(Len, &quot;0~5 kb&quot;, &quot;5+ kb&quot;) ) table(geneInfo2$LenSorted) ## ## 0~5 kb 5+ kb ## 96 865 genelist2Len0 &lt;- geneInfo2[geneInfo2$LenSorted==&quot;0~5 kb&quot;, c(&quot;geneSymbol&quot;)] pileupPath2Len0 &lt;- paste0(&quot;../pileup/&quot;, genelist2Len0, &quot;_pileup_part_intron.RData&quot;) genelist2Len5 &lt;- geneInfo2[geneInfo2$LenSorted==&quot;5+ kb&quot;, c(&quot;geneSymbol&quot;)] pileupPath2Len5 &lt;- paste0(&quot;../pileup/&quot;, genelist2Len5, &quot;_pileup_part_intron.RData&quot;) In the plot_GBC() function, evenly spaced regions are defined as gene body percentile where the number of regions is 100. Unstable patterns in base coverage especially in short genes are still detected even after filtering low-expression genes. GBC0 = plot_GBC( pileupPath = pileupPath2Len0, geneNames = genelist2Len0, sampleInfo = sampleInfo ) GBC5 = plot_GBC( pileupPath = pileupPath2Len5, geneNames = genelist2Len5, sampleInfo = sampleInfo ) p0 &lt;- GBC0$plot + coord_cartesian(ylim=c(0, 0.017)) + ggtitle(&quot;0~5 kb&quot;) p5 &lt;- GBC5$plot + coord_cartesian(ylim=c(0, 0.017)) + ggtitle(&quot;5+ kb&quot;) ggpubr::ggarrange(p0, p5, common.legend=TRUE, legend=&quot;bottom&quot;, nrow=1) "],["data-analysis.html", "5 Data Analysis 5.1 Measures by RNA-seq protocol 5.2 Suboptimal/Optimal index 5.3 Updated gene body coverage", " 5 Data Analysis 5.1 Measures by RNA-seq protocol Choi et al. (2021)2 suggested decay rate by the mean-corrected slope of log-transformed data to measure the extent of degradation and identify degraded samples in mRNA-seq. SCISSOR::decay.rate.hy() calculates slopes and decay rates for all samples with exon-only coverage pileupData. d &lt;- dim(pileupData)[1] data.process &lt;- SCISSOR::process_pileup( pileupData = pileupData, Ranges = exonRanges, ogshiftVal = 10, plotNormalization = F ) decayRate &lt;- SCISSOR::decay.rate.hy(Data=data.process$normalizedData)$slope*d In case of a long gene FAT1 with fresh frozen and mRNA-seq (FFM) 589 samples from TCGA-LUAD, total length d is 16,167 and slope is calculated by fitting a linear regression of genomic positions and the mean-corrected coverage. In the mean-corrected coverage figure, each sample is categorized as Intact or Degraded based on the median value of decayRate, enabling comparison of degradation effects on base-level coverage. The degraded samples having relatively larger slopes show lower coverage. In our package, we focus on a novel approach based on window coefficient of variation (wCV) to assess RNA-seq data quality for total RNA-seq. 5.2 Suboptimal/Optimal index A mean coverage depth (MCD) and wCV can be calculated from the get_MCD() and get_wCV() functions. To adjust the effect of low base coverage to CV, we consider wCV within a restricted range of MCD. Both functions return the same dimension of a matrix, which is the number of genes \\(\\times\\) the number of samples. MCD.mat = get_MCD( genelist = genelist, pileupPath = pileupPath, sampleInfo = sampleInfo ) wCV.mat = get_wCV( genelist = genelist, pileupPath = pileupPath, sampleInfo = sampleInfo ) The get_SOI() function gives the AUC of the fitted lines in the regression of wCV and log transformed MCD, and normalizes it using projection depth (PD)3. Finally, we can determine the quality of the samples by defining them as Suboptimal if PD&gt;cutoff. Nineteen out of 171 samples are classified as suboptimal samples. The SOI plot shows the distribution of AUC and PD and the shape of the regression by sample quality. result = get_SOI(MCD=MCD.mat, wCV=wCV.mat, rstPct=20, obsPct=50) auc.vec &lt;- result$auc.vec table(auc.vec$SOI) ## ## Optimal Suboptimal ## 152 19 plot_SOI(SOIresult=result) 5.3 Updated gene body coverage The gene body coverage plot from Data Processing can be updated after removing suboptimal samples using the plot_GBCos() function. The coverage patterns become much more stable, especially in the long genes. GBCg0 = plot_GBCos( sampleInfo = sampleInfo, GBCresult = GBC0, auc.vec = result$auc.vec ) GBCg5 = plot_GBCos( sampleInfo = sampleInfo, GBCresult = GBC5, auc.vec = result$auc.vec ) This function provides a continuous legend option to select such as ratio intron or PD for the line color. pg0 &lt;- GBCg0$plotPD + coord_cartesian(ylim=c(0, 0.017)) + ggtitle(&quot;0~5 kb&quot;) pg5 &lt;- GBCg5$plotPD + coord_cartesian(ylim=c(0, 0.017)) + ggtitle(&quot;5+ kb&quot;) ggpubr::ggarrange(pg0, pg5, common.legend=TRUE, legend=&quot;bottom&quot;, nrow=1) Choi, H.Y., Jo, H., Zhao, X. et al. SCISSOR: a framework for identifying structural changes in RNA transcripts. Nat Commun 12, 286 (2021). https://doi.org/10.1038/s41467-020-20593-3↩︎ Choi, H. (2018). Scissor for finding outliers in RNA-seq. https://doi.org/10.17615/dv2e-7a29↩︎ "],["applications.html", "6 Applications 6.1 Principal component analysis 6.2 Window CV heatmap 6.3 Sample quality summary", " 6 Applications 6.1 Principal component analysis The wCV values directly affect to AUC in the restricted MCD when the fitted regression lines are very different per sample. Since AUC is used to get SOI, we can check how PC scores of wCV are related to SOI. After handling missing values, let’s keep genes having positive variance within samples. wCV.mat2 &lt;- wCV.mat wCV.mat2[is.na(wCV.mat2)] &lt;- 0 wCV.mat2 &lt;- wCV.mat2[apply(wCV.mat2, 1, var)!=0, ] stats::prcomp() function performs PCA, and its result can be applied to calculate pc1_contributions to figure out contributions of each gene to the PC1. pca_result &lt;- prcomp(t(wCV.mat2), scale=TRUE) pc1_contributions &lt;- abs(pca_result$rotation[, 1]) top_genes &lt;- order(pc1_contributions, decreasing=TRUE) 6.2 Window CV heatmap A heatmap from ComplexHeatmap helps to visualize patterns of the wCV matrix with genes and samples properties. To construct row and column annotations, additional variables can be added by matching genes and samples: AUC, PD, and SOI from Suboptimal/Optimal index PC1, PC2, and PC1 contributions from Principal component analysis The columns are split as 2 clusters by dendrogram, which is corresponding to most of suboptimal samples. 6.3 Sample quality summary table1::table1() function displays descriptive statistics by a categorical variable. We can simply review mean and range of sample properties by sample quality for general comparison. library(table1) table1( ~ AUC + PD + RINs + RatioIntron | SOI, data = SplAnnomat, render.continuous = function(x) { sprintf(&quot;%.2f [%.2f, %.2f]&quot;, mean(x, na.rm=TRUE), min(x, na.rm=TRUE), max(x, na.rm=TRUE)) } ) Optimal(N=152) Suboptimal(N=19) Overall(N=171) AUC 0.48 [0.42, 0.59] 0.83 [0.67, 1.01] 0.52 [0.42, 1.01] PD -0.23 [-2.25, 2.13] 6.79 [3.74, 10.34] 0.55 [-2.25, 10.34] RINs 5.77 [1.30, 9.20] 2.79 [1.10, 4.60] 5.44 [1.10, 9.20] Missing 3 (2.0%) 1 (5.3%) 4 (2.3%) RatioIntron 1.94 [0.46, 4.07] 1.32 [0.57, 2.80] 1.87 [0.46, 4.07] "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
